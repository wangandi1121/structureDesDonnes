数据库：
0.组合两个表：
select FirstName,LastName,City,State 
from Person left join Address
on Person.PersonId = Address.PersonId;
表Person中Personid是主键，表Address中Personid是外键，因此使用左连接。
from子句中on条件主要用来连接表，其他不属于连接表的条件可以使用where子句来指定； 
join连接分为三种，1内连接，2外连接，3交叉连接； 
1：inner join ，默认，所以可以省略inner关键字 .
2：left outer join ，左外连接，结果表中除了匹配行外，还包括左表有而右表中不匹配的行.
右外连接，结果表中除了匹配行外，还包括右表有而左表中不匹配的行.
自然连接，分为natural left outer join和natural right outer join，语义定义与inner join相同 .
3：cross join，交叉连接，实际上就是将两个表进行笛卡尔积运算，结果表的行数等于两表行数之积.


1.获取第二高的薪水：
	select ifNull(
(select distinct Salary 	from Employee
	order by Salary desc
	limit 1 offset 1),null)
as SecondHighestSalary;


i.考虑到成绩可能有一样的值，所以使用distinct 成绩进行成绩去重。
ii. order by关键字默认升序排列，使用desc关键字可以降序。
iii. limit n子句表示查询结果返回前n条数据
offset x表示跳过x条语句
limit y offset x 分句表示查询结果跳过 x 条数据，读取前 y 条数据
iv. 题目要求，如果没有第二高的成绩，返回空值，所以这里用判断空值的函数（ifnull）函数来处理特殊情况。
ifnull(a,b)函数解释：
如果value1不是空，结果返回a
如果value1是空，结果返回b
eg.
-- 取3条，从第 5 个开始
select name from students limit 3 offset 4
-- 取4条，从第 4 个开始
select name from students limit 3, 4


2.获取第n高的薪水：
同薪同名且不跳级的问题，解决办法是用group by按薪水分组后再order by
排名第N高意味着要跳过N-1个薪水，由于无法直接用limit N-1，所以需先在函数开头处理N为N=N-1。
注：这里不能直接用limit N-1是因为limit和offset字段后面只接受正整数（意味着0、负数、小数都不行）或者单一变量（意味着不能用表达式），也就是说想取一条，limit 2-1、limit 1.1这类的写法都是报错的。

CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
    SET N := N-1;
  RETURN (
	select distinct Salary from Employee order by Salary desc
	limit N,1
      );
END

3.分数排名
值得注意的三个窗口函数。现在给定五个成绩：99，99，85，80，75。
DENSE_RANK()。如果使用 DENSE_RANK() 进行排名会得到：1，1，2，3，4。
RANK()。如果使用 RANK() 进行排名会得到：1，1，3，4，5。
ROW_NUMBER()。如果使用 ROW_NUMBER() 进行排名会得到：1，2，3，4，5。


select Score,dense_rank() over(order by Score desc) as ‘Rank’ from Scores

4.找到至少连续出现3次的数字
select distinct
l1.num as ConsecutiveNums
from Logs l1,Logs l2,Logs l3
where l1.Id = l2.Id-1 and l2.Id = l3.Id-1 and l1.num = l2.num and l2.num = l3.num;
 
5.超过经理收入的员工
由于员工和经理的信息都在一个表上，为了比较我们可以使用笛卡尔积或者使用join on
select a.name as Employee
from Employee as a, Employee as b
where a.ManagerId = b.Id and a.salary>b.salary
//
select a.name as Employee
from Employee as a join Employee as b
on a.ManagerId = b.Id and a.salary>b.salary
 
6.查找重复的电子邮箱
select email from Person 
group by email 
having count(email)>1
 
7.从不订购的客户
select Customers.name as 'Customers' from Customers
where Customers.Id not in (
    select CustomerId from Orders
);
 
8.部门中工资最高的员工
 
关系型数据库（主要为 Mysql）
1.数据库三范式：
1NF：每一列都是不可再分的最小数据单元；
2NF：如果一个关系满足1NF，并且除了主键以外的其它列，都依赖与该主键；
3NF：任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

2.分别说一下范式和反范式的优缺点：
-范式的优点：更新快，冗余少，修改少，查询快
-范式的缺点：查询的关联多，会增加查询的代价，也可能使一些索引策略无效。
- 反范式的优点：
可以避免关联，因为所有的数据几乎都可以在一张表上显示；可以设计有效的索引；
- 反范式的缺点：
表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失。

3.Mysql 数据库索引。B+ 树和 B 树的区别：

4.为什么 B+ 树比 B 树更适合应用于数据库索引，除了数据库索引，还有什么地方用到了（操作系统的文件索引）：

5.聚簇索引和非聚簇索引：
6.前缀索引和覆盖索引：
7.介绍一下数据库的事务：

8.Mysql 有哪些隔离级别”
9.Mysql 什么情况会造成脏读、可重复度、幻读？：
10.Mysql 在可重复度的隔离级别下会不会有幻读的情况，为什么？：

11.Mysql 事务是如何实现的：

12.谈一谈 MVCC 多版本并发控制 :
Innodb 和 MyISAM 的区别是什么
Innodb 的默认加锁方式是什么，是怎么实现的
如何高效处理大库 DDL
Mysql 索引重建
对于多列索引，哪些情况下能用到索引，哪些情况用不到索引
为什么使用数据库索引可以提高效率，在什么情况下会用不到数据库索引？
共享锁和排他锁的使用场景，
关系型数据库和非关系数据库的优缺点
Mysql 什么情况会造成慢查，如何查看慢查询
如何处理慢查询，你一般是怎么处理慢查询的
Mysql 中 varchar 和 char 的区别
数据库外键的优缺点
有没有使用过数据库的视图
Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？
Mysql 有哪些数据类型，使用的时候有没有什么注意点
Mysql 集群有哪几种方式，分别适用于什么场景
Mysql 主从模式如何保证主从强一致性
Mysql 集群如何保证主从可用性
Mysql 读写分离有哪些解决办法


非关系型数据库
redis 的底层数据结构有哪些
redis 中的 SDS 和 C 语言中的字符串有什么区别，优点是什么
redis 中的字典是如何实现的，如何解决冲突和扩容
redis 的跳表的使用场景是什么，可以实现一下吗
redis 缓存穿透，缓存击穿，缓存雪崩，热点数据集中失效 （常问）
redis 的淘汰策略，来写一下 LRU 吧
redis 的持久化方式，RDB 和 AOF 分别的使用场景
redis 如何处理事务
redis 为什么那么快？
redis 是单线程为什么还那么快？
redis 的操作为什么是原子性的，如何保证原子性
redis 集群用过哪些方案，分别怎么做。讲一下一致性哈希
redis 什么情况下会出现性能问题，有什么处理办法？
有没有使用过 redis 的分布式锁，有什么优缺点
说一下 redis 的内存模型
说一下 redis 和 memcache 的区别
你用 redis 做过什么？（这里尽量不要讲只做过缓存，可以说一下队列，排行榜/计数器，发布/订阅）
Mongodb 相对于 Mysql 有哪些优势，底层索引使用的数据结构是什么，为什么要使用这个
Mongodb 中的分片是什么意思
