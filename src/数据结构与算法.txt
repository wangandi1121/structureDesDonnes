数据结构与算法：
一维：
1）数组：每次申请数组，计算机在内存中开辟一段连续地址。
	查找的时间复杂度为O(1), 插入删除时间复杂度O(n)。	
           
2）链表：查找的复杂度为O(n), 插入删除的效率为O(1)。
应用：LRU缓存——最近最少使用，由Hashmap和双向链表构成。

3）跳表：当链表有序的时候进行加速的数据结构，跳表对标平衡二叉树和二分查找，插入/删除/搜索都是O(logn)。
应用：Redis
	Q：如何提高链表线性查找的效率？
	A：增加多级索引（升维）

4）栈：先入后出，添加删除皆为O(1)，查询为O(n)（可以外面加hashmap加速）。
stack可用数组模拟，自己写一些api。栈的底层实现是vector（vector跟ArrayList的区别是vector是线程安全的，实现了serializable接口），工程用deque即可。
 API：empty(); peek(); pop(); push(E item); search(Object o).

5）队列：先入先出，添加删除皆为O(1)。
在java中，queue是一个interface，常用实现类有LinkedList和PriorityQueue，关于线程安全的实现类有ConcurrentQueue和LinkedBlockingDeque等等。
API: add(e); remove(); element();  ——>有异常抛出异常
       offer(e); poll(); peek();   ——>有异常返回特殊值

6）Deque：双端队列。是接口。
API：addFrist(); removeFirst(); getFirst(); addLast(); removeLast(); getLast();
          offerFirst(e); pollFirst(); peekFirst(); offerLast(e); pollLast(); peekLast();

7) PriorityQueue : 优先队列，插入O(1), 取出O(logN) 按照元素的优先级取出。
 优先队列的底层实现多样且复杂：heap，二叉搜索树，treap…… 
API: add(e); clear(); Comparator<? super e> comparator(); contains(Object o);
      iterator() ……
用comparator定义比较器，确定优先级。

8）哈希表：通过哈希函数把要存储的值映射到一个下标。好的哈希函数会使存储比较分散，不发生碰撞。发生哈希碰撞就拉出一个链表，当链表长度超过八时，变成红黑树存储。我们认为哈希表的平均查找/删除/添加复杂度为O(1)。最坏情况会退化成链表，复杂度为O(n)。
java中 Map：键值对，键不重复；
	Set：不重复元素的集合。

二维：
 	树：跟图最大的差别是看有没有环。用递归操作。

9）BST：左子树<根<右子树。大部分操作时间复杂度都是O(logN)。
10）heap：可以迅速找到一堆数中最大或是最小值。工程里用priorityqueue就行。
API: find-max O(1); delete-max O(logN); 
二叉堆：是一颗完全树；树中任意节点的值总>=子节点的值。
二叉堆一般通过数组实现，假设第一个元素索引为0，那么索引为i的左孩子的索引是（2*i+1），索引为i的右孩子的索引为（2*i+2）
Insert：新元素先插到数组尾部，然后依次向上调整整个堆的结构。
Delete：把堆尾元素复制到堆顶，size--，然后向下维护这个堆。

11）图：点（入度，出度）边（有向，无向）
表示方式：邻接矩阵或邻接表。
常见算法：dfs，bfs (比树多了visited()集合，是个set()).

搜索：
1）深度优先
#Python
visited = set() 

def dfs(node, visited):
   if node in visited: # terminator
   	# already visited 
   	return 

	visited.add(node) 

	# process current node here. 
	...
	for next_node in node.children(): 
		if next_node not in visited: 
			dfs(next_node, visited)
#Java
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> allResults = new ArrayList<>();
        if(root==null){
            return allResults;
        }
        travel(root,0,allResults);
        return allResults;
    }


    private void travel(TreeNode root,int level,List<List<Integer>> results){
        if(results.size()==level){
            results.add(new ArrayList<>());
        }
        results.get(level).add(root.val);
        if(root.left!=null){
            travel(root.left,level+1,results);
        }
        if(root.right!=null){
            travel(root.right,level+1,results);
        }
    }

2）广度优先
# Python
def BFS(graph, start, end):
    visited = set()
	queue = [] 
	queue.append([start]) 
	while queue: 
		node = queue.pop() 
		visited.add(node)
		process(node) 
		nodes = generate_related_nodes(node) 
		queue.push(nodes)
	# other processing work 
	…
#Java
public class TreeNode {
   int val;
   TreeNode left;
   TreeNode right;

   TreeNode(int x) {
       val = x;
   }
}

public List<List<Integer>> levelOrder(TreeNode root) {
   List<List<Integer>> allResults = new ArrayList<>();
   if (root == null) {
       return allResults;
   }
   Queue<TreeNode> nodes = new LinkedList<>();
   nodes.add(root);
   while (!nodes.isEmpty()) {
       int size = nodes.size();
       List<Integer> results = new ArrayList<>();
       for (int i = 0; i < size; i++) {
           TreeNode node = nodes.poll();
           results.add(node.val);
           if (node.left != null) {
               nodes.add(node.left);
           }
           if (node.right != null) {
               nodes.add(node.right);
           }
       }
       allResults.add(results);
   }
   return allResults;
}

3）Greedy贪心算法：每一步都选择当前状态下最优。贪心算法对每个子问题的解决方案都做出选择不能回退，动态规划则会保留以前的运算结果，并对当前进行选择，有回退功能。
    一旦一个问题可以通过贪心算法解决，那贪心算法一般是解决这个问题的最好方法，贪心法有高效性，其所求答案比较接近最优结果。

4）二分查找：
使用二分查找的前提条件：i. 目标函数单调性
			       ii. 存在上下界
			       iii. 能够通过索引访问
# Python
left, right = 0, len(array) - 1 
while left <= right: 
	  mid = (left + right) / 2 
	  if array[mid] == target: 
		    # find the target!! 
		    break or return result 
	  elif array[mid] < target: 
		    left = mid + 1 
	  else: 
		    right = mid - 1
// Java
public int binarySearch(int[] array, int target) {
    int left = 0, right = array.length - 1, mid;
while (left <= right) {
mid = (right - left) / 2 + left;
if (array[mid] == target) { return mid; }
 else if (array[mid] > target) { right = mid - 1; }
 else { left = mid + 1; }
}
return -1;
}
 
5）字典树：用于统计和排序大量字符串，常被搜索引擎用于文本词频统计。从根节点到某一节点路径上所有的字符连在一起，为该节点对应的字符串。
# Python
class Trie(object):
 
	def __init__(self): 
		self.root = {} 
		self.end_of_word = "#"
	def insert(self, word): 
		node = self.root 
		for char in word: 
			node = node.setdefault(char, {}) 
		node[self.end_of_word] = self.end_of_word
	def search(self, word): 
		node = self.root 
		for char in word: 
			if char not in node: 
				return False 
			node = node[char] 
		return self.end_of_word in node
	def startsWith(self, prefix): 
		node = self.root 
		for char in prefix: 
			if char not in node: 
				return False 
			node = node[char] 
		return True
//Java
class Trie {
    private boolean isEnd;
    private Trie[] next;
    /** Initialize your data structure here. */
    public Trie() {
        isEnd = false;
        next = new Trie[26];
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        if (word == null || word.length() == 0) return;
        Trie curr = this;
        char[] words = word.toCharArray();
        for (int i = 0;i < words.length;i++) {
            int n = words[i] - 'a';
            if (curr.next[n] == null) curr.next[n] = new Trie();
            curr = curr.next[n];
        }
        curr.isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        Trie node = searchPrefix(prefix);
        return node != null;
    }

    private Trie searchPrefix(String word) {
        Trie node = this;
        char[] words = word.toCharArray();
        for (int i = 0;i < words.length;i++) {
            node = node.next[words[i] - 'a'];
            if (node == null) return null;
        }
        return node;
    }
}


6）并查集：适用场景——组团配对问题。
基本操作：i.makeSet(s): 建立一个新的并查集，包含s个单元素集合。
	      ii.unionSet(x,y): 把x和y所在的集合合并，要求x和y所在的集合不相交，相交则不合并。
	      iii.find(x): 找到x所在集合的代表，用于判断两个元素是否在同一集合。
# Python
def init(p): 
	# for i = 0 .. n: p[i] = i; 
	p = [i for i in range(n)]
def union(self, p, i, j): 
	p1 = self.parent(p, i) 
	p2 = self.parent(p, j) 
	p[p1] = p2
def parent(self, p, i): 
	root = i 
	while p[root] != root: 
		root = p[root] 
	while p[i] != i: # 路径压缩 ?
		x = i; i = p[i]; p[x] = root 
	return root
// Java
class UnionFind { 
	private int count = 0; 
	private int[] parent; 
	public UnionFind(int n) { 
		count = n; 
		parent = new int[n]; 
		for (int i = 0; i < n; i++) { 
			parent[i] = i;
		}
	} 
	public int find(int p) { 
		while (p != parent[p]) { 
			parent[p] = parent[parent[p]]; 
			p = parent[p]; 
		}
		return p; 
	}
	public void union(int p, int q) { 
		int rootP = find(p); 
		int rootQ = find(q); 
		if (rootP == rootQ) return; 
		parent[rootP] = rootQ; 
		count--;
	}
}

7）剪枝
8）双向BFS
9）启发式搜索
10）红黑树
11）平衡二叉树

工程实现：
1）布隆过滤器
2）LRUCache

位运算:

排序：
